#!/bin/bash
set -e

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed. Please install it first."
    exit 1
fi

usage() {
    echo "Usage: $0 (-t|--trivy-report) <trivy-report.json> [(-o|--output) <output-file.md>] [(-d|--dependency-tree) <dependency-tree.json>]"
    echo
    echo "Options:"
    echo "  -t, --trivy-report      Trivy report JSON file (required)"
    echo "  -o, --output           Output markdown file (default: ./security-report.md)"
    echo "  -d, --dependency-tree  Dependency tree JSON file (optional)"
    echo "  -h, --help            Show this help message"
    exit 1
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--trivy-report)
            TRIVY_FILE="$2"
            shift 2
            ;;
        -o|--output)
            REPORT_FILE="$2"
            shift 2
            ;;
        -d|--dependency-tree)
            DEPS_FILE="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Error: Unknown option $1" >&2
            usage
            ;;
    esac
done

# Set default output file if not provided
if [ -z "$REPORT_FILE" ]; then
    REPORT_FILE="./security-report.md"
fi

# Check required parameters
if [ -z "$TRIVY_FILE" ]; then
    echo "Error: Missing required parameter: trivy report file" >&2
    usage
fi

# Check if files exist
if [ ! -f "$TRIVY_FILE" ]; then
    echo "Error: Trivy report file '$TRIVY_FILE' not found" >&2
    exit 1
fi

if [ -n "$DEPS_FILE" ] && [ ! -f "$DEPS_FILE" ]; then
    echo "Error: Dependency tree file '$DEPS_FILE' not found" >&2
    exit 1
fi

# Function to find dependency path in JSON tree
find_dependency_path() {
    local pkg_name=$1
    local raw_paths

    # If dependency tree file doesn't exist or is empty, return EXTERNAL
    if [ -z "$DEPS_FILE" ] || [ ! -s "$DEPS_FILE" ]; then
        echo '{"type": "EXTERNAL", "paths": []}'
        return
    fi

    # First try exact match
    raw_paths=$(jq -r --arg pkg "$pkg_name" '
        def find_paths($pkg; $current_path):
            if (.text | type) == "string" and (.text | contains($pkg)) then
                if $current_path == "" then $current_path + .text
                else $current_path + " -> " + .text
                end
            elif (.children | type) == "array" then
                (.children[] | find_paths($pkg; if $current_path == "" then .text else $current_path + " -> " + .text end))
            else
                empty
            end;
        [.[] | find_paths($pkg; "")] | unique | select(length > 0)
    ' "$DEPS_FILE")

    # If no exact match, try fuzzy match
    if [ -z "$raw_paths" ] || [ "$raw_paths" = "[]" ]; then
        raw_paths=$(jq -r --arg pkg "${pkg_name%:*}" '
            def find_paths($pkg; $current_path):
                if (.text | type) == "string" and (.text | contains($pkg)) then
                    if $current_path == "" then $current_path + .text
                    else $current_path + " -> " + .text
                    end
                elif (.children | type) == "array" then
                    (.children[] | find_paths($pkg; if $current_path == "" then .text else $current_path + " -> " + .text end))
                else
                    empty
                end;
            [.[] | find_paths($pkg; "")] | unique | select(length > 0)
        ' "$DEPS_FILE")
    fi

    # Return dependency type and paths, filtering out evicted dependencies
    if [ -z "$raw_paths" ]; then
        echo '{"type": "EXTERNAL", "paths": []}'
    else
        echo "$raw_paths" | jq -r '
            def clean_paths:
                map(select(contains("(evicted by") | not)) |
                map(select(contains("evicted by") | not)) |
                unique;

            def group_by_subproject:
                map(select(contains("com.raw-labs:"))) |
                map(capture("com.raw-labs:(?<subproject>[^:]+)")) |
                map(.subproject) |
                unique |
                map({subproject: ., paths: []}) |
                . as $groups |
                map(select(contains("com.raw-labs:"))) |
                map(capture("com.raw-labs:(?<subproject>[^:]+)") as $sub |
                    $groups[] |
                    select(.subproject == $sub.subproject) |
                    .paths += [.]) |
                unique;

            if (map(select(contains("com.raw-labs"))) | length > 0) then
                {
                    "type": "RAWLABS",
                    "paths": clean_paths,
                    "subprojects": group_by_subproject
                }
            else
                {
                    "type": "EXTERNAL",
                    "paths": clean_paths
                }
            end
        '
    fi
}

# Generate markdown report
{
    echo "# üîç Vulnerability Summary"
    echo "Generated on: $(date)"
    echo

    # Print total count
    total_vulns=$(jq -r '.Results[] | select(.Vulnerabilities) | .Vulnerabilities | length' "$TRIVY_FILE" | awk '{sum+=$1} END{print sum}')
    echo "Found $total_vulns vulnerabilities"
    echo

    # Group by dependency source
    echo "## System Dependencies"
    echo
    while IFS= read -r vuln; do
        echo "$vuln" | jq -r '"‚ö†Ô∏è \(.PkgName) (\(.Severity)) ‚Üí Fixed in: \(.FixedVersion)"'
    done < <(jq -c '.Results[] | select(.Class == "os-pkgs") | select(.Vulnerabilities) | .Vulnerabilities[]' "$TRIVY_FILE")
    echo

    echo "## Library Dependencies"
    echo

    # Only show Raw Labs section if dependency tree is provided
    if [ -n "$DEPS_FILE" ] && [ -s "$DEPS_FILE" ]; then
        has_rawlabs=false
        while IFS= read -r vuln; do
            pkg_name=$(echo "$vuln" | jq -r '.PkgName')
            dep_info=$(find_dependency_path "$pkg_name")
            if echo "$dep_info" | jq -e '.type == "RAWLABS"' > /dev/null; then
                if [ "$has_rawlabs" = false ]; then
                    echo "### From Raw Labs"
                    echo
                    has_rawlabs=true
                fi

                # Print vulnerability info
                echo "$vuln" | jq -r '"‚ö†Ô∏è \(.PkgName) (\(.Severity)) ‚Üí Fixed in: \(.FixedVersion)"'

                # Print subproject-specific paths
                echo "$dep_info" | jq -r '.subprojects[] |
                    "#### \(.subproject)" + "\n" +
                    (.paths | map("  ‚Ä¢ " + .) | join("\n")) + "\n"'
            fi
        done < <(jq -c '.Results[] | select(.Class == "lang-pkgs") | select(.Vulnerabilities) | .Vulnerabilities[]' "$TRIVY_FILE")

        if [ "$has_rawlabs" = true ]; then
            echo "### From Third-party"
            echo
        fi
    fi

    # Print external dependencies
    has_external=false
    while IFS= read -r vuln; do
        pkg_name=$(echo "$vuln" | jq -r '.PkgName')
        dep_info=$(find_dependency_path "$pkg_name")
        if echo "$dep_info" | jq -e '.type == "EXTERNAL"' > /dev/null; then
            if [ "$has_external" = false ] && [ -n "$DEPS_FILE" ] && [ -s "$DEPS_FILE" ]; then
                has_external=true
            fi
            echo "$vuln" | jq -r '"‚ö†Ô∏è \(.PkgName) (\(.Severity)) ‚Üí Fixed in: \(.FixedVersion)"'
        fi
    done < <(jq -c '.Results[] | select(.Class == "lang-pkgs") | select(.Vulnerabilities) | .Vulnerabilities[]' "$TRIVY_FILE")
} > "$REPORT_FILE"
